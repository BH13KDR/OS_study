# 파일과 메모리

프로그램이 파일을 처리할 때, OS는 파일 내용을 메모리에 올려서 조작하는데,

하나의 파일은 여러 개의 블록으로 이루어져 있다.

블록을 메모리에 할당할 때는 연속 방식 또는 불연속 방식을 사용할 수 있다.


# 방식:

파일을 열면 OS는 해당 파일 일부를 메모리로 가져옴.

수정 후 닫을 때, 변경 내용을 디스크에 다시 기록 (버퍼링, 캐싱 활용)

메모리 매핑 파일(Memory-Mapped File)
→ 파일 내용을 직접 메모리 주소 공간에 매핑하여 접근 (고속 입출력 가능)

#연속할당(Contiguous Allocation) 방식

    파일을 저장할 때, 파일 전체를 디스크 상에서 “연속된 블록”에 저장하는 방식.
    파일이 차지하는 블록들이 연속된 물리적 공간에 배치됩니다.


#연결리스트(Linked List) 방식

	파일 할당시 각 파일 블록이 디스크 상에서 흩어져 있지만,
	포인터(다음 블록 주소)를 이용해 논리적으로 연결하는 방식.

#연결리스트 모방 예제

```python
# 파일 블록을 나타내는 노드 클래스
class Node:
    def __init__(self, data):
        self.data = data      # 블록 내용
        self.next = None      # 다음 블록을 가리키는 포인터 역할

# 연결리스트 클래스 (파일 하나를 표현)
class LinkedList:
    def __init__(self):
        self.head = None

    # 파일 블록(노드) 추가
    def append(self, data):
        new_node = Node(data)

        # 첫 블록일 경우
        if self.head is None:
            self.head = new_node
            return

        # 마지막 블록까지 이동
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    # 파일을 읽는 것처럼 블록 순서 출력
    def print_blocks(self):
        current = self.head
        print("파일 블록 순서:")
        while current:
            print(f"[{current.data}] -> ", end="")
            current = current.next
        print("NULL")

    # 파일 삭제 (메모리 해제와 유사)
    def clear(self):
        self.head = None


# 실제 실행 부분
if __name__ == "__main__":
    file = LinkedList()

    # 파일 블록 생성 (파일의 각 부분)
    file.append("Block1")
    file.append("Block2")
    file.append("Block3")

    # 파일 읽기
    file.print_blocks()

    # 파일 삭제 (연결 해제)
    file.clear()

```
#실행 결화

파일 블록 순서:
[Block1] -> [Block2] -> [Block3] -> NULL
